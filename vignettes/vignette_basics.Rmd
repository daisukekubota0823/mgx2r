---
title: "Vignette mgx2r - basics"
author: "Marion Louveaux"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette mgx2r}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The goal of this vignette is to explain how to use the mgx2r package and give example of data visualisation with Plotly. It introduces the modified_read.ply() and modified_read.cellGraph() functions that allow to read the .ply files generated by MorphoGraphX and to use further their content, for instance, by visualising the mesh(es) or by doing statistics on the cell graph dataframes. For time serie visualisation, see the time serie vignette.      
N.B: this package also include a function to write an R 3D object as a .ply mesh readable by MorphoGraphX, but I will not talk about it in this vignette.

## Librairies needed

This vignette requires the mgx2r package, as well as some other additionnal packages. Plotly is a package for displaying 3D interactive graphs, the other packages are needed for colors (colorRamps and RColorBrewer), and for coding (magrittr, dplyr and glue).

```{r lib, warning = FALSE, message = FALSE, eval=TRUE}
library(colorRamps)
library(mgx2r)
library(magrittr)
library(dplyr)
library(plotly)
library(glue)
library(RColorBrewer)
```

```{r libdev, warning = FALSE, message = FALSE, eval=FALSE}
# devtools::install_github("marionlouveaux/cellviz3d")
library(cellviz3d)
```

## Loading data

Some .ply demonstration data coming from my PhD thesis are attached to this package and used here in the vignette. This dataset is a timelapse recording of the development of a shoot apical meristem of the plant \emph{Arabidopsis thaliana} expressing a membrane marker. I took one 3D stack every 12h and have 5 timepoints in total. For more information regarding the generation of this dataset, see `help.search("mgx2r-package")`.     

Here, in this first vignette, we I will select the first timepoint only. I have one .ply for the mesh and one .ply for the cellGraph.        
```{r myData, eval=TRUE}
### Full datataset
filePly <- system.file("extdata", "full/mesh/mesh_meristem_full_T0.ply", package = "mgx2r")

fileCellGraph <- system.file("extdata",  "full/cellGraph/cellGraph_meristem_full_T0.ply", package = "mgx2r")

```

As generating following plots with the full dataset might be slow, you can try with the cropped dataset.

```{r, eval=FALSE}
### Cropped dataset
filePly <- system.file("extdata", "cropped/mesh/mesh_meristem_cropped_T0.ply", package = "mgx2r")

fileCellGraph <- system.file("extdata",  "cropped/cellGraph/cellGraph_meristem_cropped_T0.ply", package = "mgx2r")

```

## Mesh and cell graph (e.g. cells and edges properties)

I load the .ply mesh with the modified_read.ply() function. This function is a modified version of read.ply function from geomorph R package to specifically read MGX ply files. I takes in account the fact that each triangular face of the mesh can get several colors (one for the label, one for the fluorescent signal projected on the mesh -membrane or microtubules-...).
```{r readPly, warning = FALSE, message = FALSE, eval=TRUE}
mgx_palette <- c("#800000", "#FF0000", "#808000", "#FFFF00",
                "#008000", "#00FF00", "#008080", "#00FFFF",
                "#000080", "#0000FF", "#800080", "#FF00FF")

myMesh <- read_mgxPly(
  file = filePly, ShowSpecimen = FALSE, addNormals = TRUE,
  MatCol = 1, header_max = 30, my_colors = mgx_palette)
str(myMesh, max.level = 1)
```

```{r, eval=FALSE, echo=FALSE}
saveRDS(myMesh, file = "mesh_meristem_full_T0.rds")
```

Over the rest of the vignette I will only show examples of visualisation with Plotly, but there is another 3D library in R called RGL.
```{r, eval=FALSE}
rgl::shade3d(myMesh)
```

To change mesh color and display the new color, you can use the following command.
```{r modifColor, eval=FALSE}
myMesh$material$color <- myMesh$allColors$Col_signal
rgl::shade3d(myMesh)
```

Information relative to cells and cell walls (resp. vertices and edges of the cell graph) are stored in a second .ply that I read with the modified_read.cellGraph() function that I wrote myself. The modified_read.cellGraph() function reads the cell graph .ply and extract two dataframes (one for the vertices informations and one for the edges informations). These two dataframes are then combined into a list.
```{r readCellGraph, eval=TRUE}
myCellGraph <- read_mgxCellGraph(fileCellGraph = fileCellGraph, header_max = 30)
myCellGraph
```

```{r, eval=FALSE, echo=FALSE}
saveRDS(myCellGraph, file = "cellGraph_meristem_full_T0.rds")
```


N.B.: to see the content of one of these function, just type its name without the parentheses.


Last but not least, I am retrieving the location of the cell centers to display the cell ID at their location.
```{r, eval=FALSE}
meshCellcenter <- myCellGraph$vertices[,c("label","x", "y", "z")]

# An other way to define the cell centers without using the cell graph would be: ## issue with the code below
# vertexCellcenter <- purrr::map(1:ncol(myMesh$allColors$Col_label), ~ 
#   myMesh$it[ which(myMesh$allColors$Col_label[,.x] == names(which(table(myMesh$allColors$Col_label[,.x]) == 1))), .x ]
# )
```


## Displaying the mesh with plotly

### To display the mesh with cell labels
```{r map3D, eval=FALSE}
p1 <- plotlyMesh(meshExample = myMesh,
                 meshColors = myMesh$allColors$Col_label,
                 meshCellcenter = meshCellcenter) %>%
  layout(scene =
           list(
             aspectmode = "data"
           ))

p1
```

```{r echo=FALSE}
knitr::include_graphics(system.file("img", "full/p1labels.png", package = "mgx2r"))
```
Colors of the cell labels are set from the HEX color codes stored in `myMesh$allColors$Col_label`. There is always three colors: one per vertex. Two are identica, and usually black with MGX ("#000000" HEX code).      


### Without the cell labels
```{r map3D2, eval=FALSE}
plotlyMesh(meshExample = myMesh,
           meshColors = NULL,
           meshCellcenter = meshCellcenter)%>%
  layout(scene =
           list(
             aspectmode = "data"
           ))
```

```{r echo=FALSE}
knitr::include_graphics(system.file("img", "full/p1withoutlabels.png", package = "mgx2r"))
```

Default color of the mesh and opacity are set in the defaultColor parameter of the plotlyMesh() function (see ?plotlyMesh for more informations).


## Displaying specific info from cellGraph on the mesh

The cell graph contains many information that can be added to the 3D visualisation of the mesh. I classified these information in two categories: scalars (e.g. numbers, such as growth rate, area...) and tensors (microtubule orientation, growth directions, curvature...). Below I give two examples, one with the areas and one with the principal direction of growth. If my scripts are correct, I should be able to display any scalar as for area, and any tensors, as for the principal direction of growth.


### Scalar info (area, growth rate...)
```{r heatmap3D, warning = FALSE, message = FALSE, eval=FALSE}
p2 <- plotlyMesh(meshExample = myMesh, 
           meshColors = left_join(myMesh$it_label, myCellGraph$vertices) %>%
             select(., GeometryArea),
           meshCellcenter =  meshCellcenter
) %>%
  layout(scene =
           list(
             aspectmode = "data"
           ))
p2
```

```{r echo=FALSE}
knitr::include_graphics(system.file("img", "full/p2heatmap.png", package = "mgx2r"))
```


### Vector/tensor info (principal dir of curvature...)

This part of the code is quite new and provide tools to visualise tensors, such as growth direction or curvature direction on any kind of mesh (without label, with cell label, with heatmap colors...), as long as it is already converted to a plot with plotlyMesh. The code below has not been tested extensively yet.

```{r tensors, warning = FALSE, message = FALSE, eval=FALSE}
meshPlotly <- plotlyMesh(meshExample = myMesh, 
                meshColors = NULL,
                meshCellcenter = meshCellcenter) %>%
  layout(scene =
           list(
             aspectmode = "data"
           ))

show_tensors(p = meshPlotly,
             cellGraph = myCellGraph,
             tensor_name = "CellAxiscurv10microns",
             scale = 50)
```

```{r echo=FALSE}
knitr::include_graphics(system.file("img", "full/tensors.png", package = "mgx2r"))
```


## Drawing cell contours

As some may be also interested by drawing the cell contours, I have added an example here. This kind of graph is quite ressource consuming, as it is drawing each edge one by one, as a segment. Here in this example, there is 5151 edges. This could be useful if you are looking at the accumulation of a given protein (for instance PIN1) at the membrane. The information would be stored in the edges dataframe of the cell graph and I could use it to make a heatmap on the cell contours.

```{r cellContours, eval=FALSE}
meshPlotly <- plotlyMesh(meshExample = myMesh,
           meshColors = NULL) %>%
  layout(scene =
           list(
             aspectmode = "data"
           ))

show_cellcontour(p = meshPlotly, mesh = myMesh)

```

```{r echo=FALSE}
knitr::include_graphics(system.file("img", "full/contour.png", package = "mgx2r"))
```



