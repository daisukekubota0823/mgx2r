---
title: "Vignette MorphoGraphX2R"
author: "Marion Louveaux"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

## Extra librairies

```{r lib}
library(colorRamps)
library(MorphoGraphX2R)
library(magrittr)
library(dplyr)
library(plotly)
library(glue)
library(RColorBrewer)
```

## Loading data

All .ply demonstration data are stored in /inst/extdata.
```{r allData}
dirData <- "/Users/mlouveaux/Documents/Postdoc/Projects/MGX-R bridge/MorphoGraphX2R/inst/extdata"
```

We select one .ply as example.
```{r myData}
# dirPly <- "/2017-02-15_ply_files"
# 
# filePly <- paste0(dirData, dirPly, "/test4.ply")
# fileCellGraph <- paste0(dirData, dirPly, "/test4_cellGraph.ply")

dirPly <- "/Louveaux_PhD/2013-02-12_LTi6B_dis_A"

filePly <- paste0(dirData, dirPly, "/normalMesh/2013-02-12_LTi6B_dis_A_T0_cells_minW1_normalMesh.ply")
fileCellGraph <- paste0(dirData, dirPly, "/cellGraph_and_normalMeshV2/2013-02-12_LTi6B_dis_A_T0_cells_minW1_cellGraph.ply")

```


Note from 2017-12-26: read_ply_function is clean. I need now to test it on numerous meshes to make it as general as possible.


## Mesh and cell graph (e.g. cells and edges properties)

```{r readPly}
# N.B. to check mesh: put rgl viz out of modified_read.ply
myMesh <- modified_read.ply(file = filePly, ShowSpecimen = TRUE, addNormals = TRUE,
                               MatCol= 1, header_max = 30,
                               my_colors = c("#800000", "#FF0000", "#808000", "#FFFF00",
                                             "#008000", "#00FF00", "#008080", "#00FFFF",
                                             "#000080", "#0000FF", "#800080", "#FF00FF"))
```

To change mesh color and display the new color:
```{r modifColor, eval=FALSE}
myMesh$material$color <- myMesh$allColors$Col_signal
#rgl::shade3d(myMesh)
```

Information relative to cells and cell walls (resp. vertices and edges of the cell graph) are stored into two dataframes and combined into a list:
```{r readCellGraph, eval=FALSE}
myCellGraph <- modified_read.cellGraph(fileCellGraph = fileCellGraph, header_max = 30)
```



## Displaying the mesh with plotly - function
```{r}
plotlyMesh <- function(meshExample,
                       meshColors = NULL,
                       meshCellcenter = NULL){
  makeColorScale <- FALSE
  if (!is.null(nrow(meshColors)) && ncol(meshColors)>1){
    color <- NULL
    for (i in 1:ncol(meshColors)){
      color[i] <-  setdiff(unique(meshColors[,i]), "#000000") # here I remove black vertices
    } # to be more general, remove any color shared by two vertices
    opacity <- 1
  }else{
    if (is.null(meshColors)){
      color <- rep("#CCCCFF", ncol(myMesh$it)) # "#00FFFF"
      opacity <- 0.2
    }else{
      makeColorScale <- TRUE
      colorCut <- cut(pull(meshColors), 15,
                      labels =  colorRamps::matlab.like(15)
      )
      color <- as.character(colorCut)
      opacity <- 1
    }
  }
  
  trace2 <- list(type="mesh3d",
                 x = meshExample$vb[1,],
                 y = meshExample$vb[2,],
                 z = meshExample$vb[3,],
                 i = meshExample$it[1,]-1, # NB indices start at 0
                 j = meshExample$it[2,]-1,
                 k = meshExample$it[3,]-1,
                 facecolor = color, #one color per triangle (not per biological cell)
                 opacity = opacity
  )
  #facecolor: one color per triangle (e.g. length(facecolor) == length(i))
  
  if (makeColorScale){
    trace4 <- list(
      x = c(100,1,200),
      y = c(200,1,1),
      z = c(1,500,3),
      marker = list(
        autocolorscale = FALSE,
        cmax = max(meshColors),#2.5,
        cmin = min(meshColors),#0,
        colorbar = list(
          x = 1.2,
          y = 0.5,
          len = 0.3,
          thickness = 15,
          tickfont = list(size = 12),
          titlefont = list(size = 20)
        ),
        # colorscale = list(
        #   c(0, "#800026"),
        #   list(0.2, "#bd0026"),
        #   list(0.24, "#e31a1c"),
        #   list(0.28, "#fc4e2a"),
        #   list(0.32, "#fd8d3c"),
        #   list(0.36, "#feb24c"),
        #   list(0.4, "#ffffe5"),
        #   list(0.44, "#d9f0a3"),
        #   list(0.48, "#addd8e"),
        #   list(0.52, "#78c679"),
        #   list(0.56, "#41ab5d"),
        #   list(0.6, "#238443"),
        #   list(0.64, "#41b6c4"),
        #   list(0.8, "#225ea8"),
        #   list(1, "#081d58")
        # ),
        colorscale = matlab.like(15), # from colorRamps
        # reversescale = TRUE,
        line = list(width = 0),
        opacity = 0.9,
        showscale = TRUE,
        size = 20,
        symbol = "circle"
      ),
      mode = "markers",
      opacity = 0,
      type = "scatter3d"
    )
  }
  
  layout <- list(
    scene = list(
      xaxis = list(
        backgroundcolor = "rgb(230,230,230)", 
        gridcolor = "rgb(255,255,255)", 
        showbackground = TRUE, 
        zerolinecolor = "rgb(255,255,255)"
      ), 
      yaxis = list(
        backgroundcolor = "rgb(230,230,230)", 
        gridcolor = "rgb(255,255,255)", 
        showbackground = TRUE, 
        zerolinecolor = "rgb(255,255,255)"
      ), 
      zaxis = list(
        backgroundcolor = "rgb(230,230,230)", 
        gridcolor = "rgb(255,255,255)", 
        showbackground = TRUE, 
        zerolinecolor = "rgb(255,255,255)"
      )
    ), 
    title = "My mesh", 
    xaxis = list(title = "m[, 1]"), 
    yaxis = list(title = "m[, 2]")
  )
  
  p <- plot_ly()
  p <- add_trace(p, x = trace2$x, y=trace2$y, z=trace2$z,
                 facecolor=trace2$facecolor,
                 i=trace2$i, j=trace2$j, k=trace2$k, type=trace2$type,
                 opacity=trace2$opacity)
  if (makeColorScale){
    p <- add_trace(p, x=trace2$x, y=trace2$y, z=trace2$z,
                   marker = trace4$marker,
                   mode = trace4$mode,
                   opacity = trace4$opacity,
                   type = trace4$type)
  }
  if (!is.null(meshCellcenter)){ # show cell center
    p <- add_trace(p, x = meshCellcenter$x,
                     y = meshCellcenter$y,
                     z = meshCellcenter$z,
                     type = "scatter3d",
                     mode = "markers",
                   marker=list(color = 'rgb(255, 255, 255)',
                   size = 1.5)
)
  }
  p <- layout(p, scene=layout$scene, title=layout$title, xaxis=layout$xaxis, yaxis=layout$yaxis)
  
  p
}
```

To display the mesh with cell labels:
```{r map3D, eval=FALSE}
p1 <- plotlyMesh(meshExample = myMesh,
           meshColors = myMesh$allColors$Col_label)
p1
```


```{r map3D2, eval=FALSE}
plotlyMesh(meshExample = myMesh,
           meshColors = NULL)
```



## Displaying specific info from cellGraph on the mesh

### Scalar info (area, growth rate...)
```{r heatmap3D, eval=FALSE}
p2 <- plotlyMesh(meshExample = myMesh, 
           meshColors = left_join(myMesh$it_label, myCellGraph$vertices) %>%
             select(., GeometryArea),
           meshCellcenter = NULL
)
p2
```


### Vector/tensor info (principal dir of curv...)

```{r heatmap3D2, eval=FALSE}
meshCellcenter <- myCellGraph$vertices[,c("x", "y", "z")]
p3 <- plotlyMesh(meshExample = myMesh, 
                meshColors = NULL,
                meshCellcenter = meshCellcenter)

# Find coords
find_coords <- function(cellcenter, tipUnit, d, scale = 1) {
  d <- d*scale
  # Distance
  tip1 <- d / (sqrt(sum(tipUnit^2))) * tipUnit + cellcenter
  tip2 <- (-d / (sqrt(sum(tipUnit^2))) * tipUnit) + cellcenter
  tibble(x1 = tip1[1], y1 = tip1[2], z1 = tip1[3],
         x2 = tip2[1], y2 = tip2[2], z2 = tip2[3])
}

# Test avec !!
tensor_name <- "CellAxisPDG"
grand.name <- glue("{tensor_name}.{c(1:3, 7)}")
petit.name <- glue("{tensor_name}.{c(4:6, 8)}")

tmp <- myCellGraph$vertices %>%
  rename(
    tipUnit.1 = !!grand.name[1],
    tipUnit.2 = !!grand.name[2],
    tipUnit.3 = !!grand.name[3],
    d = !!grand.name[4],
  ) %>%
  mutate(grand = purrr::pmap(list(x, y, z, tipUnit.1, tipUnit.2, tipUnit.3, d),
                             ~find_coords(cellcenter = c(..1, ..2, ..3),
                                          tipUnit = c(..4, ..5, ..6),
                                          d = ..7,
                                          scale = 150))) %>%
  tidyr::unnest(grand, .sep = ".") %>%
  select(-starts_with("tipUnit"), -d) %>%
  rename(
    tipUnit.1 = !!petit.name[1],
    tipUnit.2 = !!petit.name[2],
    tipUnit.3 = !!petit.name[3],
    d = !!petit.name[4],
  ) %>%
  mutate(petit = purrr::pmap(list(x, y, z, tipUnit.1, tipUnit.2, tipUnit.3, d),
                             ~find_coords(cellcenter = c(..1, ..2, ..3),
                                          tipUnit = c(..4, ..5, ..6),
                                          d = ..7,
                                          scale = 150))) %>%
  tidyr::unnest(petit, .sep = ".") %>%
  select(-starts_with("tipUnit"), -d) %>%
  inner_join(myCellGraph$vertices)

for (i in 1:nrow(tmp)){
  xcoord <- as.vector(t(select(tmp, x, grand.x1, grand.x2)[i,]))
  ycoord <- as.vector(t(select(tmp, y, grand.y1, grand.y2)[i,]))
  zcoord <- as.vector(t(select(tmp, z, grand.z1, grand.z2)[i,]))
  p3 <- add_trace(p3, x = xcoord, y = ycoord, z = zcoord,
                 line = list(color = 'rgb(0, 0, 0)', width = 6), mode = "lines",
                 type = "scatter3d") %>%
    layout(showlegend = FALSE)
  
  xcoord <- as.vector(t(select(tmp, x, petit.x1, petit.x2)[i,]))
  ycoord <- as.vector(t(select(tmp, y, petit.y1, petit.y2)[i,]))
  zcoord <- as.vector(t(select(tmp, z, petit.z1, petit.z2)[i,]))
  p3 <- add_trace(p3, x = xcoord, y = ycoord, z = zcoord,
                 line = list(color = 'rgb(0, 0, 0)', width = 6), mode = "lines",
                 type = "scatter3d") %>%
    layout(showlegend = FALSE)

}
p3
```


## Drawing cell contours

```{r}
vertexCellcenter <- purrr::map(1:ncol(myMesh$allColors$Col_label), ~ 
  myMesh$it[ which(myMesh$allColors$Col_label[,.x] == names(which(table(myMesh$allColors$Col_label[,.x]) == 1))), .x ]
)

edgesCoords <- purrr::map(1:ncol(myMesh$allColors$Col_label), ~ 
  myMesh$vb[,myMesh$it[ which(myMesh$allColors$Col_label[,.x] != names(which(table(myMesh$allColors$Col_label[,.x])==1))), .x]]
)

p <- plotlyMesh(meshExample = myMesh,
           meshColors = NULL)

for (i in 1:length(unique(edgesCoords))){
  edge_tmp <- unique(edgesCoords)[[i]]
  xcoord <- edge_tmp[1,]
  ycoord <- edge_tmp[2,]
  zcoord <- edge_tmp[3,]
  p <- add_trace(p, x = xcoord, y = ycoord, z = zcoord,
                 line = list(color = 'rgb(0, 0, 0)', width = 6), mode = "lines",
                 type = "scatter3d") %>%
    layout(showlegend = FALSE)
}
p

```


## Adding time information

```{r}
```


- list of attributes needed: 
    *area--
    *Gaussian curvature, ---
    *principal dir of curv---
    *cell aspect ratio--
    *number of neighbours--

    *growth rate
    *growth direction
    *growth anisotropy
    
    *region
    *lineage
    *timepoint
- Export cellGraphs for each timepoint with all needed attributes
- Maps to do:
  - regions (custom label)
  - area
  - gaussian curvature
  - principal directions of curvature
  - growth rates
  - growth directions
  - cell aspect ratio
  - clonal origin (integration of all lineage maps from previous timepoints)
- Histogram of number of neighbours
- Boxplots
  - area
  - growth rate
  - growth anisotropy 
- PCA (area, growth rate, cell aspect ratio, growth anisotropy, sign of Gauss curv, curv anisotropy, abs value of Gauss curv, nb of neigh, localisation of cells = region)
- Barplot of the mitotic index (nb of div/non dividing cells)



### Map of clonal origin

I have N timepoints: 1, 2, 3, ..., N-1, N. I have the direct lineage between N-1 and N, N-2 and N-1, ..., 1 and 2. I would like to have intermediate lineages, e.g. ultimately lineage between 1 and N.

Let's say each cell at timepoint 1 is the beginning of a "track". For each cell, I'll look in time an report each link I find: cell 12 --> cell 189 (1-->2), then cell 189 --> cell 308 and cell 189 --> cell 309 (2-->3), then cell 309 --> cell 401 and cell 309 --> cell 402  and cell 308 --> 456 (3-->4), which gives:      
Track 1      
source 12 frameSource 1 target 189 frameTarget 2       
source 189 target 308       
source 189 target 309       
-- NB if "189" is not a unique ID, I need to make it unique adding the frame, for instance 2_189

And spot dataframe is:
ID_12 frame 1
ID_189 frame 2


```{r map, eval=FALSE}
dirData2 <- paste0(dirData, "/Louveaux_PhD/2013-02-12_LTi6B_dis_A")

lineages <- c("/2013-02-12_LTi6B_dis_A_T0-T12h_lineage.csv", 
  "/2013-02-12_LTi6B_dis_A_T12h-T24h_lineage.csv",
  "/2013-02-12_LTi6B_dis_A_T24h-T36h_lineage.csv",
  "/2013-02-12_LTi6B_dis_A_T36h-T48h_lineage.csv")

allLineages <- purrr::map(1:length(lineages), function(i){
  lin_tmp <- tibble::as.tibble(read.csv2(paste0(dirData2, lineages[i]), header = TRUE, sep = ","))
  lin <- dplyr::bind_cols(lin_tmp, 
                          data.frame(frameSource = rep(as.integer(i), nrow(lin_tmp)),
                                     frameTarget = rep(as.integer(i+1), nrow(lin_tmp)))) %>%
    dplyr::mutate(ID_Source = Parent.Label,
                  ID_Target = Label) %>%
    dplyr::select(ID_Source, ID_Target)
    names(lin) <- purrr::map2_chr(names(lin), c(i, i+1), ~ paste0(.x, .y))
    lin
}
)


tmp_store <- allLineages[[1]]
for (j in 2:length(lineages)){
  tmp_store <- dplyr::full_join(tmp_store, allLineages[[j]], # full join or left join?
                 by=setNames(paste0("ID_Source", j), paste0("ID_Target", j)))
}



dirData2 <- paste0(dirData, "/Louveaux_PhD/2013-02-12_LTi6B_dis_A")
plyExample <- paste0(dirData2, "/normalMesh/2013-02-12_LTi6B_dis_A_T48h_cells_minW1_normalMesh.ply")
meshExample <- MorphoGraphX2R::modified_read.ply(file = plyExample)

test <- dplyr::left_join(meshExample$it_label, tmp_store, by=c("label" = "ID_Target5")) %>%
  dplyr::select(., label, ID_Source1) %>%
  unique(.)

n.of.desc <- table(test$ID_Source1) #nb of grandchildren/descendant for this particular cell

link <- purrr::map( test$ID_Source1, function(x){
  if (length(which(as.numeric(row.names(n.of.desc)) == x)) ==0){
    NA
  }else{
    n.of.desc[which(row.names(n.of.desc) == x)]
  }
  })
unlist(link)
```


