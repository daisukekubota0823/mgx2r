---
title: "Vignette MorphoGraphX2R"
author: "Marion Louveaux"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

## Vignette Info

```{r lib}
library(magrittr)
```


All .ply demonstration data are stored in /inst/extdata.
```{r allData}
dirData <- "/Users/mlouveaux/Documents/Postdoc/Projects/MGX-R bridge/MorphoGraphX2R/inst/extdata/"
```

We select one .ply as example.
```{r myData}
dirPly <- "2017-02-15_ply_files"

filePly <- paste0(dirData, dirPly, "/test4.ply")
fileCellGraph <- paste0(dirData, dirPly, "/test4_cellGraph.ply")

```


Note from 2017-12-26: read_ply_function is clean. I need now to test it on numerous meshes to make it as general as possible.
2017-12-28: read_cellGraph looks clean as well. I need to extract the dataframes from edges and vertices properties.



```{r readPly}
myMesh <- MorphoGraphX2R::modified_read.ply(file = filePly, ShowSpecimen = TRUE, addNormals = TRUE,
                               MatCol= 1, header_max = 30,
                               my_colors = c("#800000", "#FF0000", "#808000", "#FFFF00",
                                             "#008000", "#00FF00", "#008080", "#00FFFF",
                                             "#000080", "#0000FF", "#800080", "#FF00FF"))
```

To change mesh color and display the new color:
```{r modifColor, eval=FALSE}
myMesh$material$color <- myMesh$allColors$Col_signal
#rgl::shade3d(myMesh)
```

Information relative to cells and cell walls (resp. vertices and edges of the cell graph) are stored into two dataframes and combined into a list:
```{r readCellGraph, eval=FALSE}
myCellGraph <- MorphoGraphX2R::modified_read.cellGraph(fileCellGraph = fileCellGraph, header_max = 30)
```

How to display info on a 3D rgl graph:

```{r map, eval=FALSE}

```

- list of attributes needed: 
    *area--
    *Gaussian curvature, ---
    *principal dir of curv---
    *cell aspect ratio--
    *number of neighbours--

    *growth rate
    *growth direction
    *growth anisotropy
    
    *region
    *lineage
    *timepoint
- Export cellGraphs for each timepoint with all needed attributes
- Maps to do:
  - regions (custom label)
  - area
  - gaussian curvature
  - principal directions of curvature
  - growth rates
  - growth directions
  - cell aspect ratio
  - clonal origin (integration of all lineage maps from previous timepoints)
- Histogram of number of neighbours
- Boxplots
  - area
  - growth rate
  - growth anisotropy 
- PCA (area, growth rate, cell aspect ratio, growth anisotropy, sign of Gauss curv, curv anisotropy, abs value of Gauss curv, nb of neigh, localisation of cells = region)
- Barplot of the mitotic index (nb of div/non dividing cells)



### Map of clonal origin

I have N timepoints: 1, 2, 3, ..., N-1, N. I have the direct lineage between N-1 and N, N-2 and N-1, ..., 1 and 2. I would like to have intermediate lineages, e.g. ultimately lineage between 1 and N.

Let's say each cell at timepoint 1 is the beginning of a "track". For each cell, I'll look in time an report each link I find: cell 12 --> cell 189 (1-->2), then cell 189 --> cell 308 and cell 189 --> cell 309 (2-->3), then cell 309 --> cell 401 and cell 309 --> cell 402  and cell 308 --> 456 (3-->4), which gives:      
Track 1      
source 12 frameSource 1 target 189 frameTarget 2       
source 189 target 308       
source 189 target 309       
-- NB if "189" is not a unique ID, I need to make it unique adding the frame, for instance 2_189

And spot dataframe is:
ID_12 frame 1
ID_189 frame 2


```{r map, eval=FALSE}
dirData2 <- paste0(dirData, "Louveaux_PhD/2013-02-12_LTi6B_dis_A/")

lineages <- c("2013-02-12_LTi6B_dis_A_T0-T12h_lineage.csv", 
  "2013-02-12_LTi6B_dis_A_T12h-T24h_lineage.csv",
  "2013-02-12_LTi6B_dis_A_T24h-T36h_lineage.csv",
  "2013-02-12_LTi6B_dis_A_T36h-T48h_lineage.csv")

allLineages <- purrr::map(1:length(lineages), function(i){
  lin_tmp <- tibble::as.tibble(read.csv2(paste0(dirData2, lineages[i]), header = TRUE, sep = ","))
  lin <- dplyr::bind_cols(lin_tmp, 
                          data.frame(frameSource = rep(as.integer(i), nrow(lin_tmp)),
                                     frameTarget = rep(as.integer(i+1), nrow(lin_tmp)))) %>%
    dplyr::mutate(ID_Source = paste0(Parent.Label, "_", frameSource),
                  ID_Target = paste0(Label, "_", frameTarget)) %>%
    dplyr::select(ID_Source, ID_Target)
    names(lin) <- purrr::map2_chr(names(lin), c(i, i+1), ~ paste0(.x, .y))
    lin
}
)

tmp_store <- allLineages[[1]]
for (j in 2:length(lineages)){
  tmp_store <- dplyr::full_join(tmp_store, allLineages[[j]], # full join or left join?
                 by=setNames(paste0("ID_Source", j), paste0("ID_Target", j)))
}

```






